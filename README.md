# Mini-OS
A minimal 32-bit x86 operating system built from scratch using C and Assembly, booted via GRUB2, running on QEMU, and developed on Ubuntu 24.04.

This project demonstrates OS fundamentals including:
- Booting, memory map parsing, VGA terminal, heap allocation, paging, RTC, shell, command history, and cooperative multitasking.

## High-level overview

This is a minimal 32-bit kernel that demonstrates the essential building blocks of an OS:

- Multiboot2 boot using GRUB
- Basic VGA text driver with colors and banner
- Keyboard input (including Shift/modifiers)
- Interrupt handling: PIC remap + PIT timer (100 Hz)
- Multiboot2 memory-map parsing
- Simple bump allocator (heap)
- CMOS RTC reading (time command)
- Paging enabled (32 MiB identity map)
- Small shell with commands and history
- Cooperative kernel tasking: create tasks, yield, and round-robin scheduling
- QEMU poweroff integration (clean exit)

The primary aim is education: each step is small, visible, and extendable. The code is written in C with small assembly snippets and a tiny amount of NASM boot code.

---

## Current status (what works)

- Boot: GRUB â†’ kernel (linked as `kernel.elf`) â†’ interactive shell  
- VGA banner and colored text
- Keyboard input
- Shell commands:

```
help, echo <text>, clear, halt, uptime, cpuid, reboot,
mem, memmap, alloc <n>, heap, kmstat, time, history, !!,
poweroff, taskrun, tasks, switch
```

- Paging: enabled with a 32 MiB identity mapping (kernel and heap mapped)
- Tasking: cooperative, tasks created with `taskrun` and scheduled via `task_yield()`; `switch` transfers control into task world
- `poweroff` uses QEMU's isa-debug-exit to close emulator cleanly

---

## Quick build & run (tested on Ubuntu 24.04)

**Prerequisites (install once):**
```bash
sudo apt update
sudo apt install build-essential gcc-multilib nasm grub-pc-bin xorriso qemu-system-i386
```

**Build & run:**

```bash
make clean && make
qemu-system-i386 -rtc base=localtime -cdrom build/os.iso -boot d -display gtk,gl=off \
  -no-reboot -no-shutdown -device isa-debug-exit,iobase=0xf4,iosize=0x04
```

> Use the `run` target in the Makefile: `make run` (it uses the exact QEMU command above).

---

## Notable files / structure

```
.
â”œâ”€ Makefile
â”œâ”€ linker.ld
â”œâ”€ grub/
â”‚  â””â”€ grub.cfg
â”œâ”€ src/
â”‚  â”œâ”€ boot.s        # multiboot header + _start
â”‚  â”œâ”€ kernel.c      # shell, command dispatcher, high-level glue
â”‚  â”œâ”€ vga.c         # VGA text driver
â”‚  â”œâ”€ kbd.c         # keyboard driver (with Shift)
â”‚  â”œâ”€ irq.c         # PIC remap, PIT init, IDT load, timer stub
â”‚  â”œâ”€ kalloc.c/.h   # simple bump allocator (heap)
â”‚  â”œâ”€ rtc.c/.h      # CMOS RTC reader (time command)
â”‚  â”œâ”€ paging.c/.h   # paging init (32 MiB identity map)
â”‚  â”œâ”€ task.c/.h     # basic cooperative tasking
â”‚  â””â”€ ...           # additional small helpers (cpuid, memmap printer, etc.)
â””â”€ build/           # generated by make
```

---

## How it works (very brief)

1. **GRUB loads** the kernel (`kernel.elf`) using Multiboot2.
2. `boot.s` sets a stack and calls `kernel_main`.
3. Kernel initializes VGA, IRQs, PIT timer, keyboard, heap, paging, and the shell.
4. Paging is enabled with a simple page directory/tables that identity-map the first 32 MiB.
5. Shell reads user input, keeps a small history, and dispatches commands via `run_cmd`.
6. Tasks are created by allocating a stack and setting the stack to look like a yielded context. `switch` jumps into task world; `task_yield` performs cooperative context switches.

---

## Common commands (shell)

* `mem` â€” show usable RAM (summary)
* `memmap` â€” print full multiboot memory map
* `alloc <n>` â€” allocate `n` bytes from kernel heap
* `heap` / `kmstat` â€” show heap start, pointer, and used bytes
* `time` â€” print RTC time/date (QEMU run uses `-rtc base=localtime`)
* `history` / `!!` â€” command history and re-execute last command
* `taskrun` â€” create a test kernel task
* `tasks` â€” list tasks
* `switch` â€” enter task scheduler (one-way into task world for now)
* `poweroff` â€” exit QEMU cleanly

---

## Development notes & tips

* The heap is a **simple bump allocator**. No free yet.
* Paging maps the first 32 MiB (kernel + heap). If you change heap start or kernel size, update `kalloc_init` and `paging.c` accordingly.
* `switch` currently does a one-way jump into tasks. To return to the shell you must either:

  * make the shell itself a task (recommended next step), or
  * have tasks call `poweroff` when finished.
* For clean exits from QEMU, the Makefile runs QEMU with `isa-debug-exit`. Make sure you include the `-device isa-debug-exit,iobase=0xf4,iosize=0x04` parameter.
* When changing low-level code (paging, IDT), keep a serial/console log or be ready to debug with `-serial stdio` or `-monitor stdio` to capture kernel output.

---

## Contributing & development workflow

1. Fork & clone.
2. Implement small atomic changes (one feature per PR).
3. Keep commits focused; add tests or reproducible steps for regressions.
4. If you change page structures or linking addresses, update `linker.ld` and paging constants.

---

## License & contact

This project is provided for educational purposes only.
You can contact me on- aditya308989@gmail.com

---

## Quick FAQ

* **Why GCC 32-bit flags?** Kernel is 32-bit; we compile with `-m32` and freestanding flags.
* **GRUB+Multiboot?** Using Multiboot2 simplifies hand-off of memory map and boot info.
* **QEMU time mismatch?** Use the provided QEMU args with `-rtc base=localtime` (or handle timezone in kernel).

---

Happy Hacking ðŸš€
